= cache
:!toc-title:
:!toc-placement:
:toc:

Setup a cache using AWS Elasticache. Valkey is the default engine, which is a drop-in replacement for Redis `>= 7.2`.
Read more https://aws.amazon.com/elasticache/what-is-valkey/[about valkey here].

This module is an upgrade from the previous https://github.com/nsbno/terraform-aws-redis[`terraform-aws-redis` module].

toc::[]

== Usage

Remember to check out the link:variables.tf[*variables*] and link:outputs.tf[*outputs*] to see all options.

[source,hcl]
----
module "cache" {
  source = "github.com/nsbno/terraform-aws-cache?ref=x.y.z"

  service_name       = "my-cool-train-status-thingy"
  security_group_ids = [aws_security_group.this.id]

  vpc_id     = data.aws_vpc.main.id
  subnet_ids = data.aws_subnet_ids.private.ids
}
----

== Upgrading from `terraform-aws-redis`
Remove the old module:
[source,hcl]
----
module "elasticache" {
  source = "github.com/nsbno/terraform-aws-redis?ref=x.y.z"

  application_name   = "my-cool-train-status-thingy"
  security_group_ids = [aws_security_group.this.id]

  vpc_id     = data.aws_vpc.main.id
  subnet_ids = data.aws_subnet_ids.private.ids
}
----

And then add the new one including moved statements.
The moved statements can be deleted after apply.

[WARNING]
The change from Redis to Valkey will not be applied immediately. +
Any new Terraform run will not show any
changes being made. +
Alternatively, you can use `apply_immediate_changes = true` to apply the changes immediately.

[NOTE]
Make sure the module names match in the moved blocks. There should be no created or destroyed resources after
applying. Add any missing moved blocks if needed.


[source,hcl]
----
module "cache" {
  source = "github.com/nsbno/terraform-aws-cache?ref=x.y.z"

  service_name       = "my-cool-train-status-thingy"
  security_group_ids = [aws_security_group.this.id]

  vpc_id     = data.aws_vpc.main.id
  subnet_ids = data.aws_subnet_ids.private.ids

  # Optional: Uncomment to apply changes immediately, else changes will be applied during the next maintenance window.
  # apply_immediate_changes = true
}

moved {
  from = module.elasticache.aws_elasticache_replication_group.this
  to   = module.cache.aws_elasticache_replication_group.this
}
moved {
  from = module.elasticache.aws_elasticache_subnet_group.this
  to   = module.cache.aws_elasticache_subnet_group.this
}
moved {
  from = module.elasticache.aws_security_group.this
  to   = module.cache.aws_security_group.this
}
moved {
  from = module.elasticache.aws_security_group_rule.egress_from_application_to_elasticache[0]
  to   = module.cache.aws_security_group_rule.egress_from_application_to_elasticache[0]
}
moved {
  from = module.elasticache.aws_security_group_rule.ingress_from_application_to_elasticache[0]
  to   = module.cache.aws_security_group_rule.ingress_from_application_to_elasticache[0]
}
----

== High Availability

The `availability_zones` variable decides if the cluster is spun up in high availability.

If it is set up, it will set up the amount of nodes needed to match the AZs and enable automatic failover.

== Access

Only the given `security_group_ids` can access the cluster.

If you want to grant additional services access to the cluster, make sure to either add them to the list or manually grant access using the `security_group_id` output.
